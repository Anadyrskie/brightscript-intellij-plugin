{
  parserClass="com.interfaced.brs.lang.parser.BrsParser"
  parserUtilClass="com.interfaced.brs.lang.parser.BrsParserUtil"

  elementTypeHolderClass="com.interfaced.brs.lang.psi.BrsTypes"
  elementTypeClass="com.interfaced.brs.lang.psi.BrsCompositeElementType"
  tokenTypeClass="com.interfaced.brs.lang.psi.BrsTokenType"

  psiClassPrefix="Brs"
  psiImplClassSuffix="Impl"
  psiPackage="com.interfaced.brs.lang.psi"
  psiImplPackage="com.interfaced.brs.lang.psi.impl"

  tokens = [
    T_LBRACE             = '{'
    T_RBRACE             = '}'
    T_LBRACK             = '['
    T_RBRACK             = ']'
    T_LPAREN             = '('
    T_RPAREN             = ')'
    T_COLON              = ':'
    T_COMMA              = ','
    T_EQ                 = '='
    T_DOT                = '.'
    T_LESS               = '<'
    T_GREAT              = '>'
    T_PLUS               = '+'
    T_MINUS              = '-'
    T_ASTERISK           = '*'
    T_SLASH              = '/'
    T_BACK_SLASH         = '\'
    T_DOLLAR             = '$'
    T_PERCENT            = '%'
    T_EXCLAM             = '!'
    T_SHARP              = '#'
    T_AMP                = '&'
    T_EXP                = '^'
    T_LEFT_SHIFT         = '<<'
    T_RIGHT_SHIFT        = '>>'
    T_LEFT_SHIFT_ASSIGN  = '<<='
    T_RIGHT_SHIFT_ASSIGN = '>>='
    T_ADD_ASSIGN         = '+='
    T_SUB_ASSIGN         = '-='
    T_MUL_ASSIGN         = '*='
    T_DIV_ASSIGN         = '/='
    T_BACK_DIV_ASSIGN    = '\='
    T_LESS_EQ            = '<='
    T_GREAT_EQ           = '>='
    T_INEQUAL            = '<>'
    T_LINE_TERMINATOR    = 'eol'
    T_RETURN             = 'return'
    T_DIM                = 'dim'
    T_COMMENT            = 'comment'
    T_STOP               = 'stop'
    T_GOTO               = 'goto'
    T_PRINT              = 'print'
    T_NEXT               = 'next'
    T_WHILE              = 'while'
    T_IF                 = 'if'
    T_THEN               = 'then'
    T_ELSE               = 'else'
    T_ELSE_IF            = 'elseif'
    T_FOR                = 'for'
    T_TO                 = 'to'
    T_EACH               = 'each'
    T_IN                 = 'in'
    T_FUNCTION           = 'function'
    T_SUB                = 'sub'
    T_AS                 = 'as'
    T_INTEGER            = 'integer'
    T_FLOAT              = 'float'
    T_DOUBLE             = 'double'
    T_BOOLEAN            = 'boolean'
    T_STRING             = 'string'
    T_OBJECT             = 'object'
    T_DYNAMIC            = 'dynamic'
    T_VOID               = 'void'
    T_TRUE               = 'true'
    T_FALSE              = 'false'
    T_INVALID            = 'invalid'
    T_AND                = 'and'
    T_OR                 = 'or'
    T_MOD                = 'mod'
    T_NOT                = 'not'
    T_EXIT               = 'exit'
    T_END                = 'end'
    T_STEP               = 'step'
    T_EXIT_WHILE         = 'exitwhile'
    T_EXIT_FOR           = 'exitfor'
    T_END_WHILE          = 'endwhile'
    T_END_FOR            = 'endfor'
    T_END_IF             = 'endif'
    T_END_FUNCTION       = 'endfunction'
    T_END_SUB            = 'endsub'
  ]

  consumeTokenMethod(".*_expr|expr")="consumeTokenFast"
  extends(".*expr")=expr
}

BrsProgram ::= complete_statement *

private complete_statement ::= program_statement? 'eol'
private program_statement ::= statement ( ':' statement ) *

// Statements
private statement ::=
    if
  | for
  | while
  | function
  | sub
  | assign
  | end
  | print
  | goto
  | dim
  | stop
  | return
  | expr
  | label
  | 'comment'

return ::= 'return' expr?
dim ::= 'dim' identifier dimension_list
stop ::= 'stop'
goto ::= 'goto' T_IDENTIFIER
label ::= identifier ':'
end ::= 'end'
print ::= 'print' expr
assign ::= left_expr assign_op expr {rightAssociative=true}
private left_expr ::= member_ref_expr | index_access_expr | identifier_ref_expr

for ::= ( for_counter | for_each ) ( exit_for | complete_statement ) * ( end_for | 'next' )
while ::= 'while' expr 'eol' ( exit_while | complete_statement ) * end_while
if ::= if_line | if_block
private if_line ::= 'if' expr 'then'? program_statement ( else program_statement )?
private if_block ::= 'if' expr 'then'? 'eol' complete_statement * else * end_if

else ::= ((else_if expr 'then'?) | 'else') 'eol' complete_statement *
else_if ::= ('else' 'if') | 'elseif'
private for_counter ::= 'for' identifier '=' expr 'to' expr step? 'eol'
private for_each ::= 'for' 'each' identifier 'in' identifier 'eol'
function ::= 'function' function_definition end_function
sub ::= 'sub' function_definition end_sub
private function_definition ::= identifier parameter_list as? 'eol' complete_statement *
as ::= 'as' type
type ::= 'integer' | 'float' | 'double' | 'boolean' | 'string' | 'object' | 'dynamic' | 'function' | 'void'
parameter_list ::= '(' [ !')' parameter (',' parameter) * ] ')' {pin(".*")=1}
parameter ::= identifier default? as?
default ::= '=' expr

exit_while ::= (('exit' 'while') | 'exitwhile') 'eol'
exit_for ::= (('exit' 'for') | 'exitfor') 'eol'
end_for ::= ('end' 'for') | 'endfor'
end_while ::= ('end' 'while') | 'endwhile'
end_if ::= ('end' 'if') | 'endif'
end_sub ::= ('end' 'sub') | 'endsub'
end_function ::= ('end' 'function') | 'endfunction'
step ::= 'step' expr 'eol'

// Expressions
expr ::=
    or_expr
  | and_expr
  | comp_expr
  | bit_shift_expr
  | add_expr
  | mul_expr
  | unary_expr
  | exponential_expr
  | call_expr
  | member_ref_expr
  | index_access_expr
  | primary

private primary ::= identifier_ref_expr | literal_expr | paren_expr

fake ref_expr ::= expr? '.' identifier
identifier_ref_expr ::= identifier { extends=ref_expr elementType=ref_expr }
member_ref_expr ::= expr '.' identifier {extends=ref_expr elementType=ref_expr }
call_expr ::= expr arg_list
arg_list ::= '(' [ !')' expr (',' expr) * ] ')' { pin(".*")=1 }

fake array_expr ::= expr? array
array_literal_expr ::= array { extends=array_expr elementType=array_expr }
index_access_expr ::= expr array { extends=array_expr elementType=array_expr }

array ::= '[' expr (',' expr) * ']' { pin(".*")=1 }
literal_expr ::= numeric_literal | array_literal_expr | bool_literal | object_literal | 'invalid' | T_STRING_LITERAL
numeric_literal ::= ( T_INTEGER_LIT | T_FLOAT_LIT ) ( '%' | '!' | '#' | '&' )?
private bool_literal ::= 'true' | 'false'
and_expr ::= expr 'and' expr
or_expr ::= expr 'or' expr
comp_expr ::= expr comp_op expr
bit_shift_expr ::= expr bit_shift_op expr
add_expr ::= expr add_op expr
mul_expr ::= expr mul_op expr
unary_expr ::= unary_op expr
paren_expr ::= '(' expr ')'
exponential_expr ::= expr '^' expr
object_literal ::= '{' 'eol'? [ !'}' object_property ( property_separator object_property ) * ] 'eol'? '}'
private property_separator ::= ',' | 'eol'
private object_property ::= property_identifier ':' expr
private property_identifier ::= T_IDENTIFIER | T_STRING_LITERAL

assign_op ::= '=' | '<<=' | '>>=' | '+=' | '-=' | '*=' | '/=' | '\='
comp_op ::= '<' | '>' | '=' | '>=' | '<=' | '<>'
bit_shift_op ::= '<<' | '>>'
add_op ::= '-' | '+'
mul_op ::= '*' | '/' | '\' | 'mod'
unary_op ::= 'not' | '-' | '+'

identifier ::= T_IDENTIFIER type_designator?
type_designator ::= '$' | '%' | '!' | '#' | '&'
dimension_list ::= '[' [ !']' T_INTEGER_LIT ( ',' T_INTEGER_LIT ) * ] ']' { pin(".*")=1 }
